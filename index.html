<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Chess Game</title>
    <style>
        /* ================================ CSS STYLES ================================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            transition: all 0.3s ease;
        }

        body.dark-theme {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: #ecf0f1;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
            padding: 30px;
            max-width: 900px;
            width: 100%;
            margin: 20px;
            transition: all 0.3s ease;
        }

        body.dark-theme .game-container {
            background: rgba(44, 62, 80, 0.95);
            border: 1px solid #52637a;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #e9ecef;
        }

        body.dark-theme .header {
            border-bottom-color: #52637a;
        }

        .header h1 {
            font-size: 3em;
            font-weight: bold;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #f093fb, #f5576c);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(45deg, #ffecd2, #fcb69f);
            color: #333;
        }

        /* Mode Selection Styles */
        .mode-selection {
            text-align: center;
            padding: 40px 20px;
        }

        .mode-selection h2 {
            font-size: 2.5em;
            margin-bottom: 30px;
            color: #2c3e50;
        }

        body.dark-theme .mode-selection h2 {
            color: #ecf0f1;
        }

        .mode-btn {
            display: block;
            width: 100%;
            max-width: 400px;
            margin: 20px auto;
            padding: 20px;
            font-size: 1.3em;
            border-radius: 15px;
        }

        /* Game Board Styles */
        .game-board-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 600px;
            margin-bottom: 20px;
            gap: 20px;
        }

        .player-turn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 15px 30px;
            border-radius: 15px;
            font-size: 1.2em;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .game-status {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            padding: 15px 30px;
            border-radius: 15px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .game-status.check {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
        }

        .game-status.checkmate {
            background: linear-gradient(45deg, #c44569, #f8b500);
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 600px;
            height: 600px;
            border: 4px solid #2c3e50;
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            transition: transform 0.6s ease;
        }

        .chess-board.flipped {
            transform: rotate(180deg);
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            font-size: 50px;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square:hover {
            box-shadow: inset 0 0 20px rgba(102, 126, 234, 0.4);
        }

        .square.selected {
            background-color: #667eea !important;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.3);
        }

        .square.valid-move {
            background-color: #4facfe !important;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.2);
        }

        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 25px;
            height: 25px;
            background-color: rgba(79, 172, 254, 0.8);
            border-radius: 50%;
            pointer-events: none;
        }

        .square.last-move {
            background-color: #f093fb !important;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.2);
        }

        .square.in-check {
            background-color: #ff6b6b !important;
            box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.4);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: inset 0 0 25px rgba(255, 107, 107, 0.4); }
            50% { box-shadow: inset 0 0 35px rgba(255, 107, 107, 0.8); }
            100% { box-shadow: inset 0 0 25px rgba(255, 107, 107, 0.4); }
        }

        .piece {
            transition: all 0.3s ease;
            cursor: pointer;
            user-select: none;
            filter: drop-shadow(3px 3px 6px rgba(0, 0, 0, 0.4));
        }

        .piece:hover {
            transform: scale(1.1);
            filter: drop-shadow(4px 4px 8px rgba(0, 0, 0, 0.6));
        }

        /* FIXED: Proper piece colors */
        .piece.white {
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .piece.black {
            color: #2c3e50;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.3);
        }

        .captured-pieces {
            margin-top: 20px;
            display: flex;
            justify-content: space-between;
            max-width: 600px;
            width: 100%;
        }

        .captured-white, .captured-black {
            background: rgba(0, 0, 0, 0.1);
            padding: 10px 15px;
            border-radius: 10px;
            min-height: 60px;
            flex: 1;
            margin: 0 10px;
        }

        .captured-white h4, .captured-black h4 {
            margin-bottom: 10px;
            text-align: center;
        }

        .difficulty-selection {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .difficulty-btn {
            padding: 10px 20px;
            border: 2px solid #667eea;
            background: transparent;
            color: #667eea;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .difficulty-btn:hover, .difficulty-btn.active {
            background: #667eea;
            color: white;
        }

        .hidden {
            display: none !important;
        }

        /* Animations */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .slide-in {
            animation: slideIn 0.6s ease-out;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .chess-board {
                width: 400px;
                height: 400px;
            }

            .square {
                font-size: 32px;
            }

            .game-container {
                margin: 10px;
                padding: 20px;
            }

            .header h1 {
                font-size: 2.2em;
            }

            .controls {
                flex-direction: column;
                align-items: center;
            }

            .game-info {
                flex-direction: column;
                gap: 15px;
            }
        }

        @media (max-width: 480px) {
            .chess-board {
                width: 320px;
                height: 320px;
            }

            .square {
                font-size: 24px;
            }

            .btn {
                padding: 10px 20px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <!-- ================================ HTML STRUCTURE ================================ -->
    <div class="game-container">
        <!-- Header Section -->
        <div class="header">
            <h1>üèÜ Advanced Chess Game üèÜ</h1>
            <div class="controls">
                <button class="btn btn-warning" id="theme-toggle">üåô Toggle Theme</button>
                <button class="btn btn-secondary" id="new-game-btn">üîÑ New Game</button>
                <button class="btn btn-primary" id="flip-board-btn">üîÑ Flip Board</button>
            </div>
        </div>

        <!-- Game Mode Selection -->
        <div id="mode-selection" class="mode-selection">
            <h2>Select Game Mode</h2>
            <button class="btn btn-primary mode-btn" id="vs-ai-btn">ü§ñ Play vs AI</button>
            <button class="btn btn-success mode-btn" id="vs-human-btn">üë• Play vs Human</button>
            
            <!-- AI Difficulty Selection -->
            <div id="difficulty-selection" class="difficulty-selection hidden">
                <h3>Select AI Difficulty:</h3>
                <div>
                    <button class="difficulty-btn" data-difficulty="easy">Easy</button>
                    <button class="difficulty-btn active" data-difficulty="medium">Medium</button>
                    <button class="difficulty-btn" data-difficulty="hard">Hard</button>
                </div>
            </div>
        </div>

        <!-- Game Board Section -->
        <div id="game-section" class="game-board-section hidden">
            <!-- Game Information -->
            <div class="game-info">
                <div class="player-turn" id="current-player">White's Turn</div>
                <div class="game-status" id="game-status">Game Started</div>
            </div>

            <!-- Chess Board -->
            <div class="chess-board" id="chess-board"></div>

            <!-- Captured Pieces -->
            <div class="captured-pieces">
                <div class="captured-white">
                    <h4>Captured Black Pieces</h4>
                    <div id="captured-black-pieces"></div>
                </div>
                <div class="captured-black">
                    <h4>Captured White Pieces</h4>
                    <div id="captured-white-pieces"></div>
                </div>
            </div>

            <!-- Game Controls -->
            <div class="controls" style="margin-top: 20px;">
                <button class="btn btn-secondary" id="back-to-menu-btn">üè† Back to Menu</button>
                <button class="btn btn-warning" id="undo-move-btn">‚Ü∂ Undo Move</button>
                <button class="btn btn-primary" id="hint-btn">üí° Get Hint</button>
            </div>
        </div>
    </div>

    <script>
        /* ================================ JAVASCRIPT GAME LOGIC ================================ */

        // ================================ CHESS PIECE DEFINITIONS ================================
        const PIECES = {
            KING: { white: '‚ôî', black: '‚ôö', value: 1000 },
            QUEEN: { white: '‚ôï', black: '‚ôõ', value: 9 },
            ROOK: { white: '‚ôñ', black: '‚ôú', value: 5 },
            BISHOP: { white: '‚ôó', black: '‚ôù', value: 3 },
            KNIGHT: { white: '‚ôò', black: '‚ôû', value: 3 },
            PAWN: { white: '‚ôô', black: '‚ôü', value: 1 }
        };

        // ================================ CHESS GAME CLASS ================================
        class ChessGame {
            constructor() {
                this.initializeGame();
            }

            initializeGame() {
                this.board = this.createInitialBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.validMoves = [];
                this.gameMode = null;
                this.aiDifficulty = 'medium';
                this.gameOver = false;
                this.winner = null;
                this.capturedPieces = { white: [], black: [] };
                this.moveHistory = [];
                this.lastMove = null;
                this.isFlipped = false;
                this.kingPositions = { white: [7, 4], black: [0, 4] };
            }

            createInitialBoard() {
                const board = Array(8).fill(null).map(() => Array(8).fill(null));
                
                // FIXED: Proper color assignment
                // Black pieces on top (rows 0-1)
                const blackPieces = [
                    PIECES.ROOK.black, PIECES.KNIGHT.black, PIECES.BISHOP.black, PIECES.QUEEN.black,
                    PIECES.KING.black, PIECES.BISHOP.black, PIECES.KNIGHT.black, PIECES.ROOK.black
                ];
                
                for (let col = 0; col < 8; col++) {
                    board[0][col] = { piece: blackPieces[col], color: 'black', type: this.getPieceType(blackPieces[col]) };
                    board[1][col] = { piece: PIECES.PAWN.black, color: 'black', type: 'PAWN' };
                }

                // White pieces on bottom (rows 6-7)
                const whitePieces = [
                    PIECES.ROOK.white, PIECES.KNIGHT.white, PIECES.BISHOP.white, PIECES.QUEEN.white,
                    PIECES.KING.white, PIECES.BISHOP.white, PIECES.KNIGHT.white, PIECES.ROOK.white
                ];
                
                for (let col = 0; col < 8; col++) {
                    board[6][col] = { piece: PIECES.PAWN.white, color: 'white', type: 'PAWN' };
                    board[7][col] = { piece: whitePieces[col], color: 'white', type: this.getPieceType(whitePieces[col]) };
                }

                return board;
            }

            getPieceType(pieceSymbol) {
                for (const [type, symbols] of Object.entries(PIECES)) {
                    if (symbols.white === pieceSymbol || symbols.black === pieceSymbol) {
                        return type;
                    }
                }
                return null;
            }

            isValidPosition(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            getPieceAt(row, col) {
                return this.isValidPosition(row, col) ? this.board[row][col] : null;
            }

            isSquareEmpty(row, col) {
                return this.getPieceAt(row, col) === null;
            }

            isEnemyPiece(row, col, color) {
                const piece = this.getPieceAt(row, col);
                return piece && piece.color !== color;
            }

            isOwnPiece(row, col, color) {
                const piece = this.getPieceAt(row, col);
                return piece && piece.color === color;
            }

            // ================================ MOVE VALIDATION ================================
            getValidMoves(fromRow, fromCol) {
                const piece = this.getPieceAt(fromRow, fromCol);
                if (!piece || piece.color !== this.currentPlayer) return [];

                const moves = [];
                const { type, color } = piece;

                switch (type) {
                    case 'PAWN':
                        moves.push(...this.getPawnMoves(fromRow, fromCol, color));
                        break;
                    case 'ROOK':
                        moves.push(...this.getRookMoves(fromRow, fromCol));
                        break;
                    case 'BISHOP':
                        moves.push(...this.getBishopMoves(fromRow, fromCol));
                        break;
                    case 'QUEEN':
                        moves.push(...this.getQueenMoves(fromRow, fromCol));
                        break;
                    case 'KING':
                        moves.push(...this.getKingMoves(fromRow, fromCol));
                        break;
                    case 'KNIGHT':
                        moves.push(...this.getKnightMoves(fromRow, fromCol));
                        break;
                }

                // Filter out moves that would put own king in check
                return moves.filter(([toRow, toCol]) => !this.wouldBeInCheck(fromRow, fromCol, toRow, toCol, color));
            }

            getPawnMoves(row, col, color) {
                const moves = [];
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;

                // One square forward
                if (this.isSquareEmpty(row + direction, col)) {
                    moves.push([row + direction, col]);
                    
                    // Two squares forward from starting position
                    if (row === startRow && this.isSquareEmpty(row + 2 * direction, col)) {
                        moves.push([row + 2 * direction, col]);
                    }
                }

                // Diagonal captures
                for (const colOffset of [-1, 1]) {
                    const newRow = row + direction;
                    const newCol = col + colOffset;
                    if (this.isEnemyPiece(newRow, newCol, color)) {
                        moves.push([newRow, newCol]);
                    }
                }

                return moves;
            }

            getRookMoves(row, col) {
                const moves = [];
                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                
                for (const [dRow, dCol] of directions) {
                    moves.push(...this.getLinearMoves(row, col, dRow, dCol));
                }
                
                return moves;
            }

            getBishopMoves(row, col) {
                const moves = [];
                const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                
                for (const [dRow, dCol] of directions) {
                    moves.push(...this.getLinearMoves(row, col, dRow, dCol));
                }
                
                return moves;
            }

            getQueenMoves(row, col) {
                return [...this.getRookMoves(row, col), ...this.getBishopMoves(row, col)];
            }

            getKingMoves(row, col) {
                const moves = [];
                const directions = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
                
                for (const [dRow, dCol] of directions) {
                    const newRow = row + dRow;
                    const newCol = col + dCol;
                    
                    if (this.isValidPosition(newRow, newCol)) {
                        if (this.isSquareEmpty(newRow, newCol) || this.isEnemyPiece(newRow, newCol, this.currentPlayer)) {
                            moves.push([newRow, newCol]);
                        }
                    }
                }
                
                return moves;
            }

            getKnightMoves(row, col) {
                const moves = [];
                const knightMoves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
                
                for (const [dRow, dCol] of knightMoves) {
                    const newRow = row + dRow;
                    const newCol = col + dCol;
                    
                    if (this.isValidPosition(newRow, newCol)) {
                        if (this.isSquareEmpty(newRow, newCol) || this.isEnemyPiece(newRow, newCol, this.currentPlayer)) {
                            moves.push([newRow, newCol]);
                        }
                    }
                }
                
                return moves;
            }

            getLinearMoves(row, col, dRow, dCol) {
                const moves = [];
                let newRow = row + dRow;
                let newCol = col + dCol;
                
                while (this.isValidPosition(newRow, newCol)) {
                    if (this.isSquareEmpty(newRow, newCol)) {
                        moves.push([newRow, newCol]);
                    } else if (this.isEnemyPiece(newRow, newCol, this.currentPlayer)) {
                        moves.push([newRow, newCol]);
                        break;
                    } else {
                        break;
                    }
                    newRow += dRow;
                    newCol += dCol;
                }
                
                return moves;
            }

            // ================================ GAME STATE CHECKS ================================
            isInCheck(color) {
                const kingPos = this.kingPositions[color];
                return this.isSquareUnderAttack(kingPos[0], kingPos[1], color === 'white' ? 'black' : 'white');
            }

            isSquareUnderAttack(row, col, byColor) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.getPieceAt(r, c);
                        if (piece && piece.color === byColor) {
                            const moves = this.getValidMovesForPiece(r, c, piece.type, piece.color, false);
                            if (moves.some(([moveRow, moveCol]) => moveRow === row && moveCol === col)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            getValidMovesForPiece(row, col, type, color, checkForCheck = true) {
                let moves = [];
                
                switch (type) {
                    case 'PAWN':
                        moves = this.getPawnMoves(row, col, color);
                        break;
                    case 'ROOK':
                        moves = this.getRookMoves(row, col);
                        break;
                    case 'BISHOP':
                        moves = this.getBishopMoves(row, col);
                        break;
                    case 'QUEEN':
                        moves = this.getQueenMoves(row, col);
                        break;
                    case 'KING':
                        moves = this.getKingMoves(row, col);
                        break;
                    case 'KNIGHT':
                        moves = this.getKnightMoves(row, col);
                        break;
                }

                if (checkForCheck) {
                    return moves.filter(([toRow, toCol]) => !this.wouldBeInCheck(row, col, toRow, toCol, color));
                }
                
                return moves;
            }

            wouldBeInCheck(fromRow, fromCol, toRow, toCol, color) {
                // Make the move temporarily
                const originalPiece = this.board[toRow][toCol];
                const movingPiece = this.board[fromRow][fromCol];
                
                this.board[toRow][toCol] = movingPiece;
                this.board[fromRow][fromCol] = null;
                
                // Update king position if king moved
                if (movingPiece.type === 'KING') {
                    this.kingPositions[color] = [toRow, toCol];
                }
                
                const inCheck = this.isInCheck(color);
                
                // Restore the board
                this.board[fromRow][fromCol] = movingPiece;
                this.board[toRow][toCol] = originalPiece;
                
                // Restore king position if king moved
                if (movingPiece.type === 'KING') {
                    this.kingPositions[color] = [fromRow, fromCol];
                }
                
                return inCheck;
            }

            isCheckmate(color) {
                if (!this.isInCheck(color)) return false;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.getPieceAt(row, col);
                        if (piece && piece.color === color) {
                            const validMoves = this.getValidMoves(row, col);
                            if (validMoves.length > 0) return false;
                        }
                    }
                }
                return true;
            }

            isStalemate(color) {
                if (this.isInCheck(color)) return false;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.getPieceAt(row, col);
                        if (piece && piece.color === color) {
                            const validMoves = this.getValidMoves(row, col);
                            if (validMoves.length > 0) return false;
                        }
                    }
                }
                return true;
            }

            // ================================ GAME ACTIONS ================================
            makeMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.getPieceAt(fromRow, fromCol);
                const capturedPiece = this.getPieceAt(toRow, toCol);
                
                if (!piece || piece.color !== this.currentPlayer) return false;
                
                const validMoves = this.getValidMoves(fromRow, fromCol);
                if (!validMoves.some(([r, c]) => r === toRow && c === toCol)) return false;
                
                // Store move for history
                const move = {
                    from: [fromRow, fromCol],
                    to: [toRow, toCol],
                    piece: piece,
                    capturedPiece: capturedPiece,
                    player: this.currentPlayer
                };
                
                this.moveHistory.push(move);
                this.lastMove = move;
                
                // Handle capture
                if (capturedPiece) {
                    this.capturedPieces[capturedPiece.color].push(capturedPiece);
                }
                
                // Move the piece
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;
                
                // Update king position
                if (piece.type === 'KING') {
                    this.kingPositions[piece.color] = [toRow, toCol];
                }
                
                // Switch players
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                
                // Check for game end
                this.checkGameEnd();
                
                return true;
            }

            checkGameEnd() {
                const currentColor = this.currentPlayer;
                
                if (this.isCheckmate(currentColor)) {
                    this.gameOver = true;
                    this.winner = currentColor === 'white' ? 'black' : 'white';
                } else if (this.isStalemate(currentColor)) {
                    this.gameOver = true;
                    this.winner = 'draw';
                }
            }

            undoLastMove() {
                if (this.moveHistory.length === 0) return false;
                
                const lastMove = this.moveHistory.pop();
                const { from, to, piece, capturedPiece, player } = lastMove;
                
                // Restore the piece to original position
                this.board[from[0]][from[1]] = piece;
                this.board[to[0]][to[1]] = capturedPiece;
                
                // Restore captured piece
                if (capturedPiece) {
                    const capturedIndex = this.capturedPieces[capturedPiece.color].findIndex(p => 
                        p.piece === capturedPiece.piece && p.type === capturedPiece.type
                    );
                    if (capturedIndex !== -1) {
                        this.capturedPieces[capturedPiece.color].splice(capturedIndex, 1);
                    }
                }
                
                // Update king position
                if (piece.type === 'KING') {
                    this.kingPositions[piece.color] = from;
                }
                
                // Restore player turn
                this.currentPlayer = player;
                this.gameOver = false;
                this.winner = null;
                
                // Update last move
                this.lastMove = this.moveHistory.length > 0 ? this.moveHistory[this.moveHistory.length - 1] : null;
                
                return true;
            }

            getGameStatus() {
                if (this.gameOver) {
                    if (this.winner === 'draw') {
                        return 'Stalemate - Draw!';
                    } else {
                        return `Checkmate! ${this.winner.charAt(0).toUpperCase() + this.winner.slice(1)} wins!`;
                    }
                } else if (this.isInCheck(this.currentPlayer)) {
                    return `${this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1)} is in check!`;
                } else {
                    return 'Game in progress';
                }
            }

            reset() {
                this.initializeGame();
            }
        }

        // ================================ AI PLAYER ================================
        class ChessAI {
            constructor(game, difficulty = 'medium') {
                this.game = game;
                this.difficulty = difficulty;
                this.maxDepth = this.getDepthForDifficulty(difficulty);
            }

            getDepthForDifficulty(difficulty) {
                switch (difficulty) {
                    case 'easy': return 1;
                    case 'medium': return 2;
                    case 'hard': return 3;
                    default: return 2;
                }
            }

            makeMove() {
                const bestMove = this.getBestMove();
                if (bestMove) {
                    return this.game.makeMove(bestMove.from[0], bestMove.from[1], bestMove.to[0], bestMove.to[1]);
                }
                return false;
            }

            getBestMove() {
                const possibleMoves = this.getAllPossibleMoves('black');
                if (possibleMoves.length === 0) return null;

                let bestMove = null;
                let bestScore = -Infinity;

                for (const move of possibleMoves) {
                    const score = this.evaluateMove(move);
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }

                return bestMove;
            }

            getAllPossibleMoves(color) {
                const moves = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.game.getPieceAt(row, col);
                        if (piece && piece.color === color) {
                            const validMoves = this.game.getValidMoves(row, col);
                            for (const [toRow, toCol] of validMoves) {
                                moves.push({
                                    from: [row, col],
                                    to: [toRow, toCol],
                                    piece: piece
                                });
                            }
                        }
                    }
                }
                return moves;
            }

            evaluateMove(move) {
                const [fromRow, fromCol] = move.from;
                const [toRow, toCol] = move.to;
                
                let score = 0;
                const targetPiece = this.game.getPieceAt(toRow, toCol);
                
                // Prioritize captures
                if (targetPiece) {
                    score += PIECES[targetPiece.type].value * 10;
                }
                
                // Prioritize center control
                const centerDistance = Math.abs(toRow - 3.5) + Math.abs(toCol - 3.5);
                score += (7 - centerDistance) * 2;
                
                // Add some randomness based on difficulty
                if (this.difficulty === 'easy') {
                    score += Math.random() * 50;
                } else if (this.difficulty === 'medium') {
                    score += Math.random() * 20;
                } else {
                    score += Math.random() * 5;
                }
                
                return score;
            }

            setDifficulty(difficulty) {
                this.difficulty = difficulty;
                this.maxDepth = this.getDepthForDifficulty(difficulty);
            }
        }

        // ================================ UI CONTROLLER ================================
        class ChessUI {
            constructor() {
                this.game = new ChessGame();
                this.ai = new ChessAI(this.game);
                this.isWaitingForAI = false;
                
                this.initializeElements();
                this.setupEventListeners();
                this.showModeSelection();
            }

            initializeElements() {
                this.boardElement = document.getElementById('chess-board');
                this.currentPlayerElement = document.getElementById('current-player');
                this.gameStatusElement = document.getElementById('game-status');
                this.capturedWhiteElement = document.getElementById('captured-white-pieces');
                this.capturedBlackElement = document.getElementById('captured-black-pieces');
                
                this.modeSelectionElement = document.getElementById('mode-selection');
                this.gameSectionElement = document.getElementById('game-section');
                this.difficultySelectionElement = document.getElementById('difficulty-selection');
            }

            setupEventListeners() {
                // Mode selection
                document.getElementById('vs-ai-btn').addEventListener('click', () => {
                    this.showDifficultySelection();
                });

                document.getElementById('vs-human-btn').addEventListener('click', () => {
                    this.startGame('human');
                });

                // Difficulty selection
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        const difficulty = e.target.dataset.difficulty;
                        this.ai.setDifficulty(difficulty);
                        this.startGame('ai');
                    });
                });

                // Game controls
                document.getElementById('new-game-btn').addEventListener('click', () => this.newGame());
                document.getElementById('back-to-menu-btn').addEventListener('click', () => this.showModeSelection());
                document.getElementById('flip-board-btn').addEventListener('click', () => this.flipBoard());
                document.getElementById('undo-move-btn').addEventListener('click', () => this.undoMove());
                document.getElementById('hint-btn').addEventListener('click', () => this.showHint());
                document.getElementById('theme-toggle').addEventListener('click', () => this.toggleTheme());
            }

            showModeSelection() {
                this.modeSelectionElement.classList.remove('hidden');
                this.gameSectionElement.classList.add('hidden');
                this.difficultySelectionElement.classList.add('hidden');
            }

            showDifficultySelection() {
                this.difficultySelectionElement.classList.remove('hidden');
            }

            startGame(mode) {
                this.game.gameMode = mode;
                this.game.reset();
                this.modeSelectionElement.classList.add('hidden');
                this.gameSectionElement.classList.remove('hidden');
                this.gameSectionElement.classList.add('slide-in');
                this.renderBoard();
                this.updateUI();
            }

            newGame() {
                this.game.reset();
                this.renderBoard();
                this.updateUI();
            }

            flipBoard() {
                this.game.isFlipped = !this.game.isFlipped;
                this.boardElement.classList.toggle('flipped');
            }

            undoMove() {
                if (this.game.gameMode === 'ai' && this.game.moveHistory.length >= 2) {
                    // Undo both player and AI move
                    this.game.undoLastMove();
                    this.game.undoLastMove();
                } else if (this.game.gameMode === 'human') {
                    this.game.undoLastMove();
                }
                this.renderBoard();
                this.updateUI();
            }

            showHint() {
                if (this.game.selectedSquare) {
                    const [row, col] = this.game.selectedSquare;
                    const validMoves = this.game.getValidMoves(row, col);
                    if (validMoves.length > 0) {
                        const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                        this.highlightSquare(randomMove[0], randomMove[1], 'hint');
                    }
                }
            }

            toggleTheme() {
                document.body.classList.toggle('dark-theme');
                const themeBtn = document.getElementById('theme-toggle');
                themeBtn.textContent = document.body.classList.contains('dark-theme') ? '‚òÄÔ∏è Toggle Theme' : 'üåô Toggle Theme';
            }

            renderBoard() {
                this.boardElement.innerHTML = '';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = this.createSquare(row, col);
                        this.boardElement.appendChild(square);
                    }
                }
            }

            createSquare(row, col) {
                const square = document.createElement('div');
                square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                square.dataset.row = row;
                square.dataset.col = col;

                const piece = this.game.getPieceAt(row, col);
                if (piece) {
                    const pieceElement = document.createElement('span');
                    pieceElement.className = `piece ${piece.color}`;
                    pieceElement.textContent = piece.piece;
                    square.appendChild(pieceElement);
                }

                // Highlight special squares
                this.addSquareHighlights(square, row, col);
                
                square.addEventListener('click', () => this.handleSquareClick(row, col));
                return square;
            }

            addSquareHighlights(square, row, col) {
                // Selected square
                if (this.game.selectedSquare && 
                    this.game.selectedSquare[0] === row && this.game.selectedSquare[1] === col) {
                    square.classList.add('selected');
                }

                // Valid moves
                if (this.game.validMoves.some(([r, c]) => r === row && c === col)) {
                    square.classList.add('valid-move');
                }

                // Last move
                if (this.game.lastMove) {
                    const { from, to } = this.game.lastMove;
                    if ((from[0] === row && from[1] === col) || (to[0] === row && to[1] === col)) {
                        square.classList.add('last-move');
                    }
                }

                // King in check
                if (this.game.isInCheck(this.game.currentPlayer)) {
                    const kingPos = this.game.kingPositions[this.game.currentPlayer];
                    if (kingPos[0] === row && kingPos[1] === col) {
                        square.classList.add('in-check');
                    }
                }
            }

            highlightSquare(row, col, type) {
                setTimeout(() => {
                    const square = this.boardElement.children[row * 8 + col];
                    square.classList.add(type);
                    setTimeout(() => square.classList.remove(type), 2000);
                }, 100);
            }

            handleSquareClick(row, col) {
                if (this.game.gameOver || this.isWaitingForAI) return;

                const clickedPiece = this.game.getPieceAt(row, col);

                // If no square is selected
                if (!this.game.selectedSquare) {
                    if (clickedPiece && clickedPiece.color === this.game.currentPlayer) {
                        this.selectSquare(row, col);
                    }
                    return;
                }

                const [selectedRow, selectedCol] = this.game.selectedSquare;

                // If clicking the same square, deselect
                if (selectedRow === row && selectedCol === col) {
                    this.deselectSquare();
                    return;
                }

                // If clicking another own piece, select it
                if (clickedPiece && clickedPiece.color === this.game.currentPlayer) {
                    this.selectSquare(row, col);
                    return;
                }

                // Try to make a move
                if (this.game.makeMove(selectedRow, selectedCol, row, col)) {
                    this.deselectSquare();
                    this.renderBoard();
                    this.updateUI();

                    // AI move
                    if (this.game.gameMode === 'ai' && this.game.currentPlayer === 'black' && !this.game.gameOver) {
                        this.makeAIMove();
                    }
                } else {
                    this.deselectSquare();
                }
            }

            selectSquare(row, col) {
                this.game.selectedSquare = [row, col];
                this.game.validMoves = this.game.getValidMoves(row, col);
                this.renderBoard();
            }

            deselectSquare() {
                this.game.selectedSquare = null;
                this.game.validMoves = [];
                this.renderBoard();
            }

            makeAIMove() {
                this.isWaitingForAI = true;
                this.gameStatusElement.textContent = 'AI is thinking...';
                
                setTimeout(() => {
                    this.ai.makeMove();
                    this.renderBoard();
                    this.updateUI();
                    this.isWaitingForAI = false;
                }, 1000);
            }

            updateUI() {
                this.updatePlayerTurn();
                this.updateGameStatus();
                this.updateCapturedPieces();
            }

            updatePlayerTurn() {
                const currentPlayerName = this.game.currentPlayer.charAt(0).toUpperCase() + this.game.currentPlayer.slice(1);
                this.currentPlayerElement.textContent = this.game.gameOver ? 
                    'Game Over' : `${currentPlayerName}'s Turn`;
            }

            updateGameStatus() {
                const status = this.game.getGameStatus();
                this.gameStatusElement.textContent = status;
                
                if (this.game.gameOver) {
                    if (this.game.winner === 'draw') {
                        this.gameStatusElement.className = 'game-status';
                    } else {
                        this.gameStatusElement.className = 'game-status checkmate';
                    }
                } else if (this.game.isInCheck(this.game.currentPlayer)) {
                    this.gameStatusElement.className = 'game-status check';
                } else {
                    this.gameStatusElement.className = 'game-status';
                }
            }

            updateCapturedPieces() {
                this.capturedWhiteElement.innerHTML = this.game.capturedPieces.white
                    .map(piece => `<span class="piece white">${piece.piece}</span>`).join(' ');
                
                this.capturedBlackElement.innerHTML = this.game.capturedPieces.black
                    .map(piece => `<span class="piece black">${piece.piece}</span>`).join(' ');
            }
        }

        // ================================ INITIALIZE GAME ================================
        document.addEventListener('DOMContentLoaded', () => {
            new ChessUI();
        });
    </script>
</body>
</html>